Function CoordinatesMatch(X1, Y1, X2, Y2: Real): Boolean;Begin	CoordinatesMatch := ((X1 = X2) And (Y1 = Y2))End;Function ConnectorName(ConHandle: Handle): String;Begin	ConnectorName := GetRField(ConHandle, 'Connector Rec', 'Name')End;Function HandleIsNIL(TheHandle: Handle): Boolean;Begin	HandleIsNIL := (TheHandle = NIL)End;Function NameExists(TheName: String): Boolean;Begin	NameExists := Not(HandleIsNIL(GetObject(TheName)))End;Function Increment(Num, IncVal: Integer): Integer;Begin	Increment := (Num + IncVal)End;Function LineIsVertical(X1, Y1, X2, Y2: Real): Boolean;Begin	LineIsVertical := (Abs(Y2 - Y1) >= Abs(X2 - X1))End;Function ObjectIsSymbol(TheHandle: Handle): Boolean;Begin	ObjectIsSymbol := (GetType(TheHandle) = 15)End;Function ObjectIsLine(TheHandle: Handle): Boolean;Begin	ObjectIsLine := (GetType(TheHandle) = 2)End;Function EmptyName(TheHandle: Handle): Boolean;Begin	EmptyName := ((GetName(TheHandle) = '') Or (GetName(TheHandle) = 'none'))End;Function ObjectsMatch(PreHandle, CurHandle: Handle): Boolean;Begin	ObjectsMatch := (CurHandle = PreHandle)End;Function DeviceIsAccessory(DevHandle: Handle): Boolean;Begin	DeviceIsAccessory := (ObjectIsSymbol(DevHandle)) And (Round(Eval(DevHandle, (R In ['Accessory Info']))) = 1)End;Function DeviceIsDetection(DevHandle: Handle): Boolean;Begin	DeviceIsDetection := (ObjectIsSymbol(DevHandle)) And (Round(Eval(DevHandle, (R In ['Detection Info']))) = 1)End;Function DeviceIsPanel(DevHandle: Handle): Boolean;Begin	DeviceIsPanel := (ObjectIsSymbol(DevHandle)) And (Round(Eval(DevHandle, (R In ['Panel Info']))) = 1)End;Function DeviceIsSignal(DevHandle: Handle): Boolean;Begin	DeviceIsSignal := (ObjectIsSymbol(DevHandle)) And (Round(Eval(DevHandle, (R In ['Signal Info']))) = 1)End;Procedure SetHandle(Var Handle2: Handle; Handle1: Handle);Begin	Handle2 := Handle1End;Function GetConnector(Name: String): Handle;Var	H: Handle;		Procedure PickConnector(ConHandle: Handle);	Begin		SetName(ConHandle, (ConnectorName(ConHandle)))	End;Begin	H:= NIL;	ForEachObject(PickConnector, ('Connector Rec'.'Name' = Name));	H := GetObject(Name);	DelName(Name);	If ObjectIsSymbol(H) Then	Begin		If DeviceIsPanel(H) Then			SetName(H, (GetRField(H, 'Panel 1 Rec', 'Name')))		Else			SetName(H, (GetRField(H, 'Device Rec', 'Name')))	End;	GetConnector := HEnd;Function ObjectIsConduit(TheHandle: Handle): Boolean;Begin	ObjectIsConduit := ((Copy(ConnectorName(TheHandle),1, 1) = ConduitPrefix) And ObjectIsLine(TheHandle))End;Function GetBLink(ConHandle: Handle): Handle;Begin	GetBLink := GetConnector(GetRField(ConHandle, 'Connector Rec', 'BLink'))End;Function InPath(PreHandle, CurHandle: Handle): Boolean;Begin	While ((PreHandle <> CurHandle) And Not(HandleIsNil(CurHandle))) Do		CurHandle:= GetBLink(CurHandle);	If (PreHandle = CurHandle) Then		InPath := True	Else		InPath := FalseEnd;Procedure SetCoordinates(Var X2, Y2: Real; X1, Y1: Real);Begin	X2 := X1;	Y2 := Y1End;Procedure DeleteObjectName(ObjectName: String);Begin	If NameExists(ObjectName) Then		DelName(ObjectName)End;Procedure OriginSetup;Var	OriginX, OriginY: Real;Begin	GetOrigin(OriginX, OriginY);	If ((OriginX <> 0) | (OriginY <> 0)) Then		SetOrigin((0 - OriginX), (0 - OriginY))End;Procedure OKCancelProcess(Var DialogueDone, Cancel: Boolean; ItemID: Integer);Begin	DialogueDone := True;	If (ItemID = 1) Then		Cancel := False	Else		Cancel := TrueEnd;{Begin ConnectorIsAttached}	Function ConnectorIsAttached(ConnectorHandle: Handle): Boolean;	Begin		Message('Begin ConnectorIsAttached');		ConnectorIsAttached := (Round(Eval(ConnectorHandle, (R In ['Connector Rec']))) = 1);		Message('End ConnectorIsAttached')	End;{End ConnectorIsAttached}{Begin LineIsAngled}	Function LineIsAngled(X1, Y1, X2, Y2: Real): Boolean;	Begin		LineIsAngled := ((X2 - X1) <> 0) And ((Y2 - Y1) <> 0)	End;{End LineIsAngled}{-------------------- End Function Section --------------------}{-------------------- Begin Procedure Section --------------------}{Begin CreateConnectorRecord}	Procedure CreateConnectorRecord;	Var		NumOfFLinks, Index: Integer;		{Begin GetNumOfZones}		Procedure GetNumOfZones(PanHandle: Handle);		Var			NumOfZones, DetZones, SigZones, Index: Integer;		Begin			NumOfZones := 0;			DetZones := Str2Num(GetRField(PanHandle, 'Panel Info', 'Detection Zones'));			SigZones := Str2Num(GetRField(PanHandle, 'Panel Info', 'Signal Zones'));			If (DetZones > 0) Then				For Index := 1 To DetZones Do					NumOfZones := Increment(NumOfZones, 1);			If (GetRField(PanHandle, 'Panel Info', 'Addressable') = 'True') Then				NumOfZones := 10;			If (SigZones > 0) Then				For Index := 1 To SigZones Do					NumOfZones := Increment(NumOfZones, 1);			If (NumOfZones > NumOfFLinks) Then				NumOfFLinks := NumOfZones;		End;	{End GetNumOfZones}	Begin		Message('Begin CreateConnectorRecord');		ForEachObject(GetNumOfZones, (R In ['Panel Info']));		NumOfFLinks := Increment(NumOfFLinks, 2);		NewField('Connector Rec', 'Name', 'NIL', 4, 0);		NewField('Connector Rec', 'BLink', 'NIL', 4, 0);		NewField('Connector Rec', 'FLinks', Num2Str(0, NumOfFLinks), 4, 0);		For Index := 1 To NumOfFLinks Do			NewField('Connector Rec', Concat('FLink', Index), 'NIL', 4, 0);		NewField('Connector Rec', 'Path', '', 4, 0);		NewField('Connector Rec', 'JBox', 'False', 4, 0);		NewField('Connector Rec', 'Arc', 'False', 4, 0);		Message('End CreateConnectorRecord')	End;{End CreateConnectorRecord}{Begin SnapToGrid}	Procedure SnapToGrid(Var X, Y: Real);	Begin		Message('Begin SnapToGrid');		X := (Round(X) Div 6) * 6;		Y := (Round(Y) Div 6) * 6;		Message('End SnapToGrid')	End;{End SnapToGrid}{Begin GetCenter}	Procedure GetCenter(ObjectHandle: Handle; Var X, Y: Real);	Var		Left, Top, Right, Bottom: Real;	Begin		Message('Begin GetCenter');		GetBBox(ObjectHandle, Left, Top, Right, Bottom);		X := (Left + Right) / 2;		Y := (Top + Bottom) / 2;		Message('End GetCenter')	End;{End GetCenter}{Begin SetLeftRight}	Procedure SetLeftRight(Var Left, Right: Real; X1, X2: Real);	Begin		Message('Begin SetLeftRight');		If (X1 > X2) Then		Begin			Left := X2;			Right := X1		End		Else		Begin			Left := X1;			Right := X2		End;		Message('End SetLeftRight')	End;{End SetLeftRight}{Begin SetTopBottom}	Procedure SetTopBottom(Var Top, Bottom: Real; Y1, Y2: Real);	Begin		Message('Begin SetTopBottom');		If (Y1 > Y2) Then		Begin			Bottom := Y2;			Top := Y1		End		Else		Begin			Bottom := Y1;			Top := Y2		End;		Message('End SetTopBottom')	End;{End SetTopBottom}{Begin GetFactor}	Function GetFactor(Num1, Num2: Real): Integer;	Begin		If (Num2 > Num1) Then			GetFactor := (-1)		Else If (Num2 < Num1) Then			GetFactor := 1		Else If (Num2 = Num1) Then			GetFactor := 0	End;{End GetFactor}{Begin DoJBox}	Procedure DoJBox(ConHandle: Handle; LastFLink: Integer);	Var		FLinkHandle, NewHandle: Handle;		CX1, CY1, CX2, CY2, FX1, FY1, FX2, FY2, X, Y: Real;		Begin		Message('Begin DoJBox');		FLinkHandle := GetConnector(GetRField(ConHandle, 'Connector Rec', Concat('FLink', LastFLink)));		GetSegPt1(ConHandle, CX1, CY1);		GetSegPt2(ConHandle, CX2, CY2);		GetSegPt1(FLinkHandle, FX1, FY1);		GetSegPt2(FLinkHandle, FX2, FY2);		If CoordinatesMatch(CX1, CY1, FX1, FY1) Or CoordinatesMatch(CX1, CY1, FX2, FY2) Then			SetCoordinates(X, Y, CX1, CY1)		Else			SetCoordinates(X, Y, CX2, CY2);		Symbol('J-Box', X, Y, 0);		NewHandle := LNewObj;		SetName(NewHandle, Concat(ConnectorName(ConHandle), '-JBox'));		SetRField(ConHandle, 'Connector Rec', 'JBox', 'True');		Message('End DoJBox')	End;{End DoJBox}{Begin DoArc}	Procedure DoArc(ConHandle: Handle; LastFLink: Integer);	Const		Radius = 24;	Var		FLinkHandle, NewHandle: Handle;		CX1, CY1, CX2, CY2, FX1, FY1, FX2, FY2, X, Y, XR, YR, Hyp, Angle1, Angle2, TotalAngle, HalfAngle: Real;		DeltaX1, DeltaY1, DeltaX2, DeltaY2: Real;		XCFactor, YCFactor, XFFactor, YFFactor: Integer;		Begin		Message('Begin DoArc');		FLinkHandle := GetConnector(GetRField(ConHandle, 'Connector Rec', Concat('FLink', LastFLink)));		GetSegPt1(ConHandle, CX1, CY1);		GetSegPt2(ConHandle, CX2, CY2);		GetSegPt1(FLinkHandle, FX1, FY1);		GetSegPt2(FLinkHandle, FX2, FY2);		XCFactor := GetFactor(CX1, CX2);		YCFactor := GetFactor(CY1, CY2);		XFFactor := GetFactor(FX1, FX2);		YFFactor := GetFactor(FY1, FY2);		If CoordinatesMatch(CX1, CY1, FX1, FY1) Or CoordinatesMatch(CX1, CY1, FX2, FY2) Then			SetCoordinates(X, Y, CX1, CY1)		Else			SetCoordinates(X, Y, CX2, CY2);		If (CX1 <> CX2) Then		Begin			Angle1 := (ArcTan((CY2 - CY1) / (CX2 - CX1))) * (-XCFactor);			If (CY2 > CY1) And (CX1 > CX2) Then				Angle1 := Deg2Rad(180) - Abs(Angle1)			Else If (CY2 < CY1) And (CX1 > CX2) Then				Angle1 := Abs(Angle1) - Deg2Rad(180)		End		Else		Begin			If (CY2 > CY1) Then				Angle1 := Deg2Rad(90)			Else				Angle1 := Deg2Rad(-90)		End;		If (Round(FX2 - FX1) <> 0) Then		Begin			Angle2 := (ArcTan((FY2 - FY1) / (FX2 - FX1))) * (-XFFactor);			If (FY2 > FY1) And (FX1 > FX2) Then				Angle2 := Deg2Rad(180) - Abs(Angle2)			Else If (FY2 < FY1) And (FX1 > FX2) Then				Angle2 := Abs(Angle2) - Deg2Rad(180)		End		Else		Begin			If (FY2 > FY1) Then				Angle2 := Deg2Rad(90)			Else				Angle2 := Deg2Rad(-90)		End;	{At least one line is set at an agnle.}		If LineIsAngled(CX1, CY1, CX2, CY2) Or LineIsAngled(FX1, FY1, FX2, FY2) Then		Begin		{Get the total angle between segments.}			If Angle1 >= 0 Then			Begin				If ((Angle1 - Deg2Rad(180)) < Angle2) And (Angle2 < Angle1) Then					TotalAngle := Deg2Rad(180) - Angle1 + Angle2				Else If (Angle1 < Angle2) And (Angle2 <= Deg2Rad(180)) Then					TotalAngle := Angle1 - Angle2 + Deg2Rad(180)				Else If (Deg2Rad(-180) <= Angle2) And (Angle2 < (Angle1 - Deg2Rad(180))) Then					TotalAngle := Angle1 + Angle2 - Deg2Rad(180)			End			Else If Angle1 < 0 Then			Begin				If (Angle1 < Angle2) And (Angle2 < (Deg2Rad(180) + Angle1)) Then					TotalAngle := Deg2Rad(180) + Angle1 - Angle2				Else If ((Deg2Rad(180) + Angle1) < Angle2) And (Angle2 <= Deg2Rad(180)) Then					TotalAngle := Angle2 - Angle1 - Deg2Rad(180)				Else If (Deg2Rad(-180) <= Angle2) And (Angle2 < Angle1) Then					TotalAngle := Angle2 - Angle1 + Deg2Rad(180)			End;			HalfAngle := TotalAngle / 2;			Hyp := Radius / Tan(HalfAngle);			DeltaX1 := Abs(Hyp * Cos(Angle1));			DeltaY1 := Abs(Hyp * Sin(Angle1));			DeltaX2 := Abs(Hyp * Cos(Angle2));			DeltaY2 := Abs(Hyp * Sin(Angle2));			SetSegPt2(ConHandle, X + (DeltaX1 * XCFactor * 2), Y + (DeltaY1 * YCFactor * 2));			SetSegPt1(FLinkHandle, X - (DeltaX2 * XFFactor * 2), Y - (DeltaY2 * YFFactor * 2));			BeginPoly;				Message('Angled1 ', XCFactor, ', ', YCFactor, ', ', XFFactor, ', ', YFFactor);				Message('Angled2 ', Hyp, ', ', DeltaX1, ', ', DeltaY1, ', ', DeltaX2, ', ', DeltaY2);				Message('Move to ', X + (DeltaX1 * XCFactor * 2), ', ', Y + (DeltaY1 * YCFactor * 2));				MoveTo(X + (DeltaX1 * XCFactor * 2), Y + (DeltaY1 * YCFactor * 2));				Message('Line to ', X + (DeltaX1 * XCFactor), ', ', Y + (DeltaY1 * YCFactor));				LineTo(X + (DeltaX1 * XCFactor), Y + (DeltaY1 * YCFactor));				ArcTo(X, Y, Radius);				Message('Line to ', X - (DeltaX2 * XFFactor * 2), ', ', Y - (DeltaY2 * YFFactor * 2));				LineTo(X - (DeltaX2 * XFFactor * 2), Y - (DeltaY2 * YFFactor * 2));			EndPoly;		End		Else		Begin		{The two lines are vertical and horizontal or vise-versa.}			SetSegPt2(ConHandle, X + (Cos(Angle1) * (Radius * 2) * XCFactor), Y - (Sin(Angle1) * (Radius * 2)));			SetSegPt1(FLinkHandle, X - (Cos(Angle2) * (Radius * 2) * XFFactor), Y + (Sin(Angle2) * (Radius * 2)));			BeginPoly;				MoveTo(X + (Cos(Angle1) * (Radius * 2) * XCFactor), Y - (Sin(Angle1) * (Radius * 2)));				LineTo(X + (Cos(Angle1) * Radius * XCFactor), Y - (Sin(Angle1) * Radius));				ArcTo(X, Y, Radius);				LineTo(X - (Cos(Angle2) * (Radius * 2) * XFFactor), Y + (Sin(Angle2) * (Radius * 2)));			EndPoly;		End;		NewHandle := LNewObj;		SetName(NewHandle, Concat(ConnectorName(ConHandle), '-Arc'));		SetRField(ConHandle, 'Connector Rec', 'Arc', 'True');		Message('End DoArc')	End;{End DoArc}{Begin DoIntersection}	Procedure DoIntersection(ConHandle: Handle);	Var		Index, MaxFLink, FLinkNum, LastFLink, X1Factor, Y1Factor, X2Factor, Y2Factor: Integer;		NoSymbol: Boolean;		FLinkHandle: Handle;		CX1, CY1, CX2, CY2, FX1, FY1, FX2, FY2, X, Y, Angle1, Angle2: Real;		ConName: String;		NewHandle: Handle;		Begin		Message('Begin DoIntersection');		MaxFLink := Round(Str2Num(GetRField(ConHandle, 'Connector Rec', 'FLinks')));		FLinkNum := 0;		NoSymbol := True;		For Index := 1 To MaxFLink Do			If (GetRField(ConHandle, 'Connector Rec', Concat('FLink', Index)) <> 'NIL') Then			Begin				FLinkNum := FLinkNum + 1;				LastFLink := Index;				If (ObjectIsSymbol(GetConnector(GetRField(ConHandle, 'Connector Rec', Concat('FLink', Index))))) Then					NoSymbol := False			End;		If (NoSymbol) And (FLinkNum > 1) And Not(ObjectIsSymbol(ConHandle)) And (GetRField(ConHandle, 'Connector Rec', 'JBox') = 'False') Then			DoJBox(ConHandle, LastFLink)		Else If (NoSymbol) And (FLinkNum = 1) And Not(ObjectIsSymbol(ConHandle)) And (GetRField(ConHandle, 'Connector Rec', 'Arc') = 'False') Then		Begin			DoArc(ConHandle, LastFLink);		End;		For Index := 1 To MaxFLink Do		Begin			If (GetRField(ConHandle, 'Connector Rec', Concat('FLink', Index)) <> 'NIL') Then			Begin				DoIntersection(GetConnector(GetRField(ConHandle, 'Connector Rec', Concat('FLink', Index))))			End		End;		Message('End DoIntersection')	End;{End DoIntersection}{Begin FindIntersections}	Procedure FindIntersections;	Var		NILString: String;	Begin		Message('Begin FindIntersections');		NILString := 'NIL';		ForEachObject(DoIntersection, ('Connector Rec'.'BLink' = NILString));		Message('End FindIntersections')	End;{End FindIntersections}{-------------------- End Procedure Section --------------------}